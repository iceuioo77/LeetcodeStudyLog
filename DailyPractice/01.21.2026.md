# Two Pointers Pattern 
> 适用题型：排序数组 / 双指针 / 去重  
> 目的：从「会做」→「能解释」→「可迁移」

---

## 题目一：LeetCode 167 — Two Sum II

### 1. 题目关键信息
- 数组是否有序：是的
- 返回的是（下标 / 数值）：下标
- 下标是否 1-based：是的
- 是否允许重复使用元素：不允许

---

### 2. 我的第一反应
> 不写代码，只写思路

- 我第一时间想到的解法：左右各一个指针，往中间找
- 为什么能利用「有序」这个条件：可以用双指针
- 我放弃了哪些解法，为什么：双层循环，时间复杂度太高

---

### 3. 最优解核心思想
> 用一句话描述算法本质

- 使用的数据结构 / 指针：双指针
- 搜索区间如何变化：由(0,len(numbers)逐渐向中间缩紧
- 不变式（始终成立的条件）：left<right

---

### 4. 指针移动规则（为什么这样动）
| 当前情况 | 动哪个指针 | 原因 |
|--------|-----------|------|
| sum < target |左指针|增大数值 |
| sum > target |右指针 |减小数值 |
| sum == target |不变 |找到一个解 |

---

### 5. 容易犯的错误
- 我最开始犯过的错误：不知道用while循环，想用for循环；没把sum = numbers[left] + numbers[right] 放在while循环里
- 为什么这是错的：终止值是状态用while循环；放在while外，sum值一直不根据left和right改变
- 我以后如何避免：终止值是数值用for循环，终止值是状态用while循环；需要改变的值放在前提循环内

---

## 题目二：LeetCode 15 — 3Sum

### 1. 题目关键信息
- 返回的是：值，三元组
- 是否允许重复三元组：不允许
- 是否允许重复使用元素：不允许

---

### 2. 暴力解法复盘
- 暴力解法是什么：三重循环
- 时间复杂度：O(n^3)
- 为什么不可行：时间复杂度太高，消耗内存大，执行时间长

---

### 3. 从 3 重循环 → 双指针的转变
> 写出你的“顿悟点”

- 哪一步让我意识到可以降维：和两数之和一样可以找出两个数等于另一个数的负数
- 排序在这里起到的作用：方便使用双指针

---

### 4. 外层循环设计（i）
- i 代表什么角色：另外两个数相加等于的值的负数
- 为什么需要外层去重：因为如果是同一个值，会在内层找到相同的三元组
- 外层去重条件（用人话写）：如果现在这个i等于我上一个使用的就跳过

---

### 5. 内层双指针设计（left / right）
- left / right 各自的移动方向：left向右👉，right向左👈
- 内层循环的终止条件：left<right
- 指针移动的决策依据：和两数之和相同

---

### 6. 去重策略（最容易混）
> 不写代码，用「方向 + 时机」解释

#### 外层去重
- 去重的对象：i
- 去重发生的时机：现在的值等于上一个值
- 为什么是回头看：因为和前面已经使用过的对比，以便跳过现在的值

#### 内层去重
- 去重的对象：left/right
- 去重发生的时机：下一个left/right值等于现在的
- 为什么是向前看：和下一个对比，如果一样直接将指针移动到下一个值
- 为什么去重后还要再移动一次指针：因为前一次移动了指针到的还是和上一个值相同的那个值

---

### 7. 控制流理解（return / continue）
- 哪些地方用 continue：还需要继续执行代码的地方
- 为什么不能在内层 return：没有得到所有的三元组结果
- return 应该放在哪一层，为什么：和for循环一层，这样才能得到所有i组成的所有三元组

---

### 8. 我踩过的坑
> 尤其记录「当时为什么会这样写」

- 逻辑层面的坑：分不清外层循环和内层循环的去重方向是不同的
- Python 语法 / 运算符坑：&是java的语法，and才是python的语法；==判断两个值是否相等
- 缩进 / 越界问题：return一定要在最外层

---

### 9. 如果让我重新写一次
- 我现在最清楚的一点是：return要在最外层
- 我最容易再犯错的一点是：外层循环和内层循环去重
- 我会重点检查的 3 行代码：外层循环和内层循环去重的判断条件，什么时候跳过值


